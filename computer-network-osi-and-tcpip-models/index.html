<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>计算机网络之七 - OSI 与 TCP/IP 分层模型 | Rakuyo&#39;s blog</title>

<link rel="shortcut icon" href="https://blog.rakuyo.dev/favicon.ico?v=1769154921003">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.rakuyo.dev/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
        <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script> 
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Rakuyo&#39;s blog
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/reference" class="menu gt-a-link">
                    收藏
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/friends" class="menu gt-a-link">
                    友链
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1769154921003"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    计算机网络之七 - OSI 与 TCP/IP 分层模型
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2025-09-04 ·
                    </time>
                    
                        <a href="https://blog.rakuyo.dev/tag/ji-suan-ji-wang-luo/" class="post-tags">
                            # 计算机网络
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>本篇是计算机网络系列的第七篇。在前面的文章中，我们已经分别探讨了 IP、DNS、DHCP、TCP、HTTP 等具体的技术点。然而，这些技术并非孤立存在，它们是一个庞大而精密的系统中的有机组成部分。为了理解它们如何协同工作，我们需要一个宏观的框架来审视整个网络世界。这个框架，就是网络分层模型。</p>
<!-- more -->
<blockquote>
<p>终于轮到分层模型了。其实在绝大多数讲计算机网络的文章中都会在一开始就介绍分层模型，但是我每次读到这种文章时，都会被其庞大的架构所阻拦 —— 它太完美，也太完整，我貌似没法一下子完全理解与接受。所以本系列文章并没有选择从分层模型入手，也有这方面的原因。</p>
</blockquote>
<p>本文将作为系列的一个阶段性总结，涉及到业界最核心的两个网络模型——OSI 七层模型和 TCP/IP 模型。我们不仅将理解它们是什么，更将探讨它们为何如此设计、关键协议的内部细节、设计哲学的差异，以及它们在现实世界中的局限性，帮助你将先前学到的知识“融会贯通”，构建一个系统性的网络知识体系。</p>
<p>其余几篇的目录：</p>
<ul>
<li><a href="/computer-network-ip-and-port/">计算机网络之一 - IP 与端口</a></li>
<li><a href="/computer-network-url-and-dns/">计算机网络之二 - URL 与 DNS</a></li>
<li><a href="/computer-network-dhcp-and-intranet-penetration/">计算机网络之三 - DHCP 与内网穿透</a></li>
<li><a href="/computer-network-virtual-nic-and-wireguard/">计算机网络之四 - 虚拟网卡与 WireGuard</a></li>
<li><a href="/computer-network-http-and-https/">计算机网络之五 - HTTP 与 HTTPS</a></li>
<li><a href="/computer-network-tcp-and-udp/">计算机网络之六 - 可靠的 TCP 与高效的 UDP</a></li>
</ul>
<hr>
<h2 id="为什么需要网络分层">为什么需要网络分层</h2>
<p>在深入模型细节之前，我们首先要回答一个根本问题：为什么网络通信需要“分层”？</p>
<p>想象一个极其复杂的跨国寄送包裹的流程。如果我们将整个流程视为一个单一的、巨大的任务，那么任何一个环节的微小变动（例如更换了运送卡车），都可能需要重新设计整个系统，这无疑是低效且脆弱的。</p>
<p>一个更合理的设计是将其模块化，即分层。每一层都只关心自己的任务，并为上一层提供服务，同时使用下一层提供的服务。这种设计带来了几个显而易见的好处：</p>
<ul>
<li><strong>简化问题</strong>：将一个复杂的大问题分解为多个简单的小问题。</li>
<li><strong>标准化</strong>：每一层都可以建立统一的标准（如 RFC），只要接口不变，任何一方的内部实现变化都不会影响其他层。</li>
<li><strong>解耦合</strong>：不同层的技术可以独立发展和演进。例如，我们可以将物理传输从电缆升级到光纤，而无需改变上层的网页浏览体验。</li>
<li><strong>易于教学和排错</strong>：当网络出现问题时，我们可以逐层排查，极大地提高了故障定位的效率。</li>
</ul>
<p>当然，分层也并非没有代价，例如数据在各层之间传递会带来一定的性能开销。但在绝大多数场景下，其带来的结构性优势远大于性能上的微小损失。</p>
<h2 id="osi-七层参考模型理论的丰碑">OSI 七层参考模型：理论的丰碑</h2>
<p><strong>OSI 模型（Open Systems Interconnection model）</strong> 是由国际标准化组织（ISO）提出的一个概念模型，旨在为计算机网络提供一个标准的、通用的体系架构。它被誉为理论上最完整、最严谨的网络模型，虽然在商业上并未取得绝对的成功，但它对于理解网络通信的各个环节具有极高的指导价值。</p>
<p>OSI 模型将网络通信精确地划分为了七个层次。下面我们自顶向下逐层解析其功能与核心协议。</p>
<ul>
<li>
<p><strong>第七层：应用层 (Application Layer)</strong><br>
这是用户最直接接触的一层，负责为应用程序提供网络服务。它定义了应用程序之间如何交换和解释数据。正如我们在 <a href="/computer-network-http-and-https/">《计算机网络之五 - HTTP 与 HTTPS》</a> 中探讨的 HTTP 协议，就工作在这一层。</p>
</li>
<li>
<p><strong>第六层：表示层 (Presentation Layer)</strong><br>
表示层主要处理数据的格式化、加密和压缩，确保一个系统的应用层所发送的数据能被另一个系统的应用层正确理解。它如同一个“翻译官”。</p>
</li>
<li>
<p><strong>第五层：会话层 (Session Layer)</strong><br>
这一层负责建立、管理和终止不同设备间的会话（Session）。</p>
</li>
<li>
<p><strong>第四层：传输层 (Transport Layer)</strong><br>
传输层为两个主机之间提供端到端（end-to-end）的数据传输服务。其协议数据单元（PDU）称为<strong>数据段 (Segment)</strong>。</p>
</li>
<li>
<p><strong>第三层：网络层 (Network Layer)</strong><br>
网络层负责在复杂的网络环境中，为数据包选择最佳的路由路径，实现逻辑地址（IP 地址）的寻址。其 PDU 称为<strong>数据包 (Packet)</strong>。</p>
</li>
<li>
<p><strong>第二层：数据链路层 (Data Link Layer)</strong><br>
数据链路层负责在<strong>相邻</strong>的两个网络节点之间传输数据帧。它处理物理地址（MAC 地址）的寻址。其 PDU 称为<strong>数据帧 (Frame)</strong>。</p>
</li>
<li>
<p><strong>第一层：物理层 (Physical Layer)</strong><br>
这是模型的最底层，负责传输原始的二进制比特流（0和1）。其 PDU 称为<strong>比特 (Bit)</strong>。</p>
</li>
</ul>
<h2 id="tcpip-模型实践的胜利者">TCP/IP 模型：实践的胜利者</h2>
<p>与 OSI 的理论性不同，<strong>TCP/IP 模型</strong>是伴随着互联网的实践发展而来的，是当前事实上的工业标准。在深入其结构之前，我们先回答一个问题：它为什么叫 “TCP/IP” 模型？</p>
<h3 id="名字的由来">名字的由来</h3>
<p>这个模型得名于其体系中的两个最核心、最基础的协议：</p>
<ol>
<li><strong>TCP (传输控制协议)</strong>：工作在传输层，提供可靠的、面向连接的数据传输服务。它如同网络通信的“质量总监”。</li>
<li><strong>IP (网际协议)</strong>：工作在网络层，负责数据包的寻址和路由。它如同网络通信的“全球邮政系统”。</li>
</ol>
<p>TCP 和 IP 的重要性如此之高，以至于它们成为了整个协议族（Protocol Suite）的代名词。因此，描述这个协议族架构的模型，也就自然而然地被称为 “TCP/IP 模型”。</p>
<h3 id="分层结构">分层结构</h3>
<p>TCP/IP 模型更加简洁和实用，通常被描述为四层或五层模型。</p>
<h4 id="tcpip-四层模型">TCP/IP 四层模型</h4>
<p>这是最经典的 TCP/IP 模型划分，它将功能相近的几个层进行了合并，更侧重于描述协议簇的宏观结构：</p>
<ul>
<li><strong>应用层 (Application Layer)</strong>：对应 OSI 的应用层、表示层、会话层。包含了所有高层协议，如 HTTP, FTP, DNS 等。</li>
<li><strong>传输层 (Transport Layer)</strong>：对应 OSI 的传输层。负责端到端的通信，核心是 TCP 和 UDP 协议。</li>
<li><strong>网际层 (Internet Layer)</strong>：对应 OSI 的网络层。核心是 IP 协议，负责数据包的寻址和路由。</li>
<li><strong>网络接口层 (Network Interface Layer)</strong>：对应 OSI 的数据链路层和物理层。负责处理与物理网络媒介（如以太网、Wi-Fi）相关的所有事务。</li>
</ul>
<h4 id="tcpip-五层模型">TCP/IP 五层模型</h4>
<p>为了教学和理解上的便利，业界更常使用一个五层模型。它实际上是 OSI 和 TCP/IP 四层模型的一个折中，将四层模型中的“网络接口层”重新拆分为“数据链路层”和“物理层”，从而能更清晰地描述底层的工作原理。<strong>这个五层模型也是我们后续文章将主要参照的结构</strong>。</p>
<ul>
<li><strong>应用层 (Application Layer)</strong>：同四层模型，对应 OSI 的上三层。</li>
<li><strong>传输层 (Transport Layer)</strong>：同四层模型，对应 OSI 的传输层。</li>
<li><strong>网络层 (Network Layer)</strong>：同四层模型的网际层，对应 OSI 的网络层。</li>
<li><strong>数据链路层 (Data Link Layer)</strong>：对应 OSI 的数据链路层。</li>
<li><strong>物理层 (Physical Layer)</strong>：对应 OSI 的物理层。</li>
</ul>
<p>下面的表格清晰地展示了三者之间的映射关系：</p>
<table style="width:100%; border-collapse: collapse; text-align: center;">
  <thead style="background-color:#f2f2f2;">
    <tr>
      <th style="width:33%; border: 1px solid #ddd; padding: 8px;">OSI 七层参考模型</th>
      <th style="width:33%; border: 1px solid #ddd; padding: 8px;">TCP/IP 五层模型</th>
      <th style="width:33%; border: 1px solid #ddd; padding: 8px;">TCP/IP 四层模型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>应用层</b></td>
      <td rowspan="3" style="border: 1px solid #ddd; padding: 8px; vertical-align: middle;"><b>应用层</b></td>
      <td rowspan="3" style="border: 1px solid #ddd; padding: 8px; vertical-align: middle;"><b>应用层</b></td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>表示层</b></td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>会话层</b></td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>传输层</b></td>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>传输层</b></td>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>传输层</b></td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>网络层</b></td>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>网络层</b></td>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>网际层</b></td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>数据链路层</b></td>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>数据链路层</b></td>
      <td rowspan="2" style="border: 1px solid #ddd; padding: 8px; vertical-align: middle;"><b>网络接口层</b></td>
    </tr>
    <tr>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>物理层</b></td>
      <td style="border: 1px solid #ddd; padding: 8px;"><b>物理层</b></td>
    </tr>
  </tbody>
</table>
<h2 id="核心协议深度剖析">核心协议深度剖析</h2>
<p>理解了分层，我们还需要深入协议的内部，看看它们是如何通过精巧的设计来完成各自使命的。</p>
<h3 id="网络层核心ipv4-头部结构">网络层核心：IPv4 头部结构</h3>
<p>我们在 <a href="/computer-network-ip-and-port/">《计算机网络之一 - IP 与端口》</a> 中已经初步认识了 IP 协议，它是整个网络层的核心。为了更深入地理解数据包是如何被路由的，我们有必要详细剖析其头部结构：</p>
<pre><code>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>版本 (Version)</strong>：4位，指明协议版本，对 IPv4 来说就是 4。</li>
<li><strong>首部长度 (IHL)</strong>：4位，表示 IP 头部有多少个 32 位字（4字节）。由于该字段最大值为 15，所以 IP 头部最长为 <code>15 * 4 = 60</code> 字节。</li>
<li><strong>服务类型 (Type of Service)</strong>：8位，用于指定数据包的服务质量（QoS），例如低延迟、高吞吐量或高可靠性。现在通常被定义为 DSCP（差分服务代码点）。</li>
<li><strong>总长度 (Total Length)</strong>：16位，指明整个 IP 数据包（头部+数据）的总长度，单位是字节。最大长度为 65535 字节。</li>
<li><strong>标识 (Identification)</strong>、<strong>标志 (Flags)</strong> 和 <strong>片偏移 (Fragment Offset)</strong>：这三个字段共同用于 IP 分片。当一个数据包的大小超过了链路的最大传输单元（MTU）时，它必须被分割成多个小的数据包（分片）。
<ul>
<li><code>标识</code>：16位，唯一标识一个原始数据包。同一原始数据包的所有分片都具有相同的标识号。</li>
<li><code>标志</code>：3位。第一位保留；第二位是 <code>DF</code> (Don't Fragment)，如果置 1，表示禁止分片；第三位是 <code>MF</code> (More Fragments)，如果置 1，表示后面还有更多分片，如果是最后一个分片则为 0。</li>
<li><code>片偏移</code>：13位，指明当前分片的数据部分在原始数据包中的位置。</li>
</ul>
</li>
<li><strong>生存时间 (Time to Live, TTL)</strong>：8位，数据包在网络中的“寿命”。每经过一个路由器，TTL 值减 1。当 TTL 变为 0 时，数据包被丢弃。这有效防止了数据包在网络中因路由错误而无限循环。</li>
<li><strong>协议 (Protocol)</strong>：8位，指明该数据包承载的上层协议是什么。例如，<code>6</code> 代表 TCP，<code>17</code> 代表 UDP。接收方据此决定将数据交给哪个上层模块处理。</li>
<li><strong>首部校验和 (Header Checksum)</strong>：16位，用于检验 IP 头部的完整性，不包含数据部分。由于 TTL 在每一跳都会改变，所以路由器需要重新计算校验和。</li>
<li><strong>源地址/目标地址 (Source/Destination Address)</strong>：各 32 位，标识了数据包的发送方和接收方。</li>
<li><strong>选项 (Options)</strong> 和 <strong>填充 (Padding)</strong>：选项是可变长的，用于一些特殊处理，如记录路由。填充用于确保整个 IP 头部是 32 位的整数倍。</li>
</ul>
<h3 id="传输层核心tcp-与-udp">传输层核心：TCP 与 UDP</h3>
<p>传输层负责端到端的通信，其两大核心协议 TCP 和 UDP，我们已在之前的文章中做了详细的探讨。</p>
<p>TCP 通过序列号、确认号、标志位等头部关键字段，以及<strong>三次握手</strong>和<strong>四次挥手</strong>等严谨的连接管理机制，提供了可靠的、面向连接的服务。关于这些内部工作细节，强烈建议您回顾 <strong><a href="/computer-network-tcp-and-udp/">《计算机网络之六 - 可靠的 TCP 与高效的 UDP》</a></strong>，本文不再赘述。</p>
<h3 id="网络层的路由协议">网络层的路由协议</h3>
<p>IP 协议只负责数据包的投递，但如何确定投递路径，则是由<strong>路由协议</strong>决定的。路由协议在路由器之间运行，共同构建和维护路由表。它们主要分为两大流派：</p>
<ul>
<li><strong>距离矢量协议 (Distance-Vector)</strong>：如 <code>RIP</code>。每个路由器只知道与它直接相邻的邻居，并与它们交换整个路由表。它关心的是“到某个目的地有多远（距离）”和“应该从哪个方向（矢量）走”。这种方式简单，但容易产生路由环路且收敛慢。</li>
<li><strong>链路状态协议 (Link-State)</strong>：如 <code>OSPF</code>。每个路由器都拥有整个网络的拓扑图。当网络状态变化时，路由器会向所有其他路由器广播这个变化。它关心的是“整个网络的连接状态”。这种方式更复杂，但收敛快且不易产生环路。</li>
</ul>
<h2 id="osi-与-tcpip一场理论与实践的赛跑">OSI 与 TCP/IP：一场理论与实践的赛跑</h2>
<p>一个经典问题是：为什么理论上更完美的 OSI 模型，在实践中却输给了更“粗糙”的 TCP/IP 模型？</p>
<ol>
<li>
<p><strong>时机决定一切</strong>：TCP/IP 诞生于 20 世纪 70 年代，与美国国防部的 ARPANET 项目紧密结合，经过了长期的实践检验。当 OSI 模型在 80 年代后期完成其标准化工作时，TCP/IP 早已在学术界和军事领域广泛部署，形成了强大的事实标准。</p>
</li>
<li>
<p><strong>哲学差异</strong>：OSI 遵循“先制定标准，再进行实现”的学院派哲学，力求大而全，导致其过于复杂。而 TCP/IP 则源于“先有可用实现，再提炼标准”的工程师哲学，更注重解决实际问题，因此更简洁、高效。</p>
</li>
<li>
<p><strong>实现复杂度</strong>：OSI 模型的复杂性（尤其是会话层和表示层）使得其实现难度和运行开销都很大。相比之下，TCP/IP 将这些功能交由应用层自行处理，大大降低了核心网络的复杂度。</p>
</li>
</ol>
<p>最终，这场赛跑以实践派的胜利告终。OSI 虽然输掉了市场，但它清晰的层次划分和严谨的定义，使其成为了网络教育和理论分析不可或缺的“教科书”。</p>
<h2 id="应用模型从理论到实践">应用模型：从理论到实践</h2>
<p>理解了分层模型这一“地图”，我们便拥有了分析和诊断网络问题的框架。接下来，我们将通过两个具体的案例，将这些抽象的层次和协议应用到实际场景中。第一个案例将展示一次标准网络请求的完整流程，第二个案例则将剖析一个常见的开发陷阱，以展示分层模型在排错中的指导价值。</p>
<h3 id="案例一一次完整的-http-请求">案例一：一次完整的 HTTP 请求</h3>
<p>这个案例将追踪一次典型的、访问外部网站的 HTTP 请求，以展示数据包如何穿越互联网。</p>
<p><strong>场景设定</strong>：</p>
<ul>
<li><strong>你的电脑</strong>：IP <code>192.168.1.100</code> (此地址通常通过 DHCP 服务动态获取，相关细节请回顾 <a href="/computer-network-dhcp-and-intranet-penetration/">《计算机网络之三 - DHCP 与内网穿透》</a>), MAC <code>AA:AA:AA:AA:AA:AA</code></li>
<li><strong>家庭路由器</strong>：内网 IP <code>192.168.1.1</code>, MAC <code>BB:BB:BB:BB:BB:BB</code>；公网 IP <code>123.123.123.123</code></li>
<li><strong>目标网站服务器</strong>：IP <code>216.58.200.46</code>, MAC <code>CC:CC:CC:CC:CC:CC</code></li>
</ul>
<p><strong>旅程开始</strong>：</p>
<ol start="0">
<li>
<p><strong>DNS 查询</strong>：在一切开始之前，浏览器需要知道 <code>example.com</code> 的 IP 地址。它会向 DNS 服务器发起查询，将域名解析为 IP 地址 <code>216.58.200.46</code>。关于 DNS 的详细工作原理，请参阅 <a href="/computer-network-url-and-dns/">《计算机网络之二 - URL 与 DNS》</a>。</p>
</li>
<li>
<p><strong>应用层</strong>：你在浏览器输入 <code>http://example.com</code>。浏览器构建一个 HTTP GET 请求报文。</p>
</li>
<li>
<p><strong>传输层</strong>：操作系统为该请求分配一个临时的<strong>源端口</strong>（如 <code>54321</code>），目标端口为 HTTP 的标准端口 <code>80</code>。然后，它将 HTTP 报文封装进一个 TCP 数据段，并写入 TCP 头部（包含源/目标端口等信息）。</p>
</li>
<li>
<p><strong>网络层</strong>：操作系统继续封装，添加 IP 头部，形成 IP 数据包。头部信息包括<strong>源 IP</strong> (<code>192.168.1.100</code>) 和<strong>目标 IP</strong> (<code>216.58.200.46</code>)。</p>
</li>
<li>
<p><strong>数据链路层 (第一跳：电脑 -&gt; 路由器)</strong>：</p>
<ul>
<li>操作系统查询路由表，发现目标 IP <code>216.58.200.46</code> 不在本地网络，需发往<strong>默认网关</strong> (<code>192.168.1.1</code>)。</li>
<li>操作系统使用 <a href="/computer-network-dhcp-and-intranet-penetration/">ARP 协议</a>查询 <code>192.168.1.1</code> 对应的 MAC 地址，得到路由器的 MAC <code>BB:BB:BB:BB:BB:BB</code>。</li>
<li>最终，它构建一个以太网帧，头部包含<strong>源 MAC</strong> (<code>AA:AA...</code>) 和<strong>目标 MAC</strong> (<code>BB:BB...</code>)，并将 IP 数据包作为其“货物”。</li>
</ul>
</li>
<li>
<p><strong>物理层</strong>：电脑网卡将该数据帧转换为电信号，通过网线发送出去。</p>
</li>
<li>
<p><strong>在路由器上 (关键中转)</strong>：</p>
<ul>
<li>路由器的数据链路层接收到数据帧，检查目标 MAC 是自己，于是“拆开”帧，取出 IP 数据包，并将其向上传递到网络层。</li>
<li>路由器的网络层执行 <strong>NAT (网络地址转换)</strong>。它将 IP 包的<strong>源 IP</strong> 从 <code>192.168.1.100</code> 修改为自己的<strong>公网 IP</strong> <code>123.123.123.123</code>，并记录下这个映射关系，以便响应回来时能正确转发。</li>
<li>路由器准备将修改后的 IP 包发往互联网。它查询自己的路由表，找到下一跳的地址，并构建一个新的数据链路层帧（此时的目标 MAC 将是下一个路由器的 MAC），然后发送出去。</li>
</ul>
</li>
<li>
<p><strong>在互联网中</strong>：数据包经过多个路由器的多次转发，每一跳都重复着“解封装-查路由-再封装”的过程，但 IP 头部的源/目标 IP 始终不变（除了 NAT 网关）。</p>
</li>
<li>
<p><strong>抵达服务器</strong>：服务器接收到数据，自底向上进行解封装，最终将 HTTP 请求报文送达 Web 服务器应用。服务器处理请求后，再以同样的方式将响应数据封装并发回。</p>
</li>
</ol>
<h3 id="案例二从-localhost-到局域网的连接问题">案例二：从 <code>localhost</code> 到局域网的连接问题</h3>
<p>本博客基于 <a href="https://github.com/getgridea/gridea">Gridea</a> 实现，该客户端提供了一个便捷的“预览”功能，点击后会在浏览器中打开 <code>http://localhost:4000</code> 这样的地址，用于实时查看文章效果。这个过程在本地电脑上运行良好，但当作者希望使用其他设备（如手机）预览地址文章时就显得力不从心了，因为这个地址在其他设备上是 “打不开” 的。</p>
<p><strong>问题的演进</strong></p>
<ol>
<li>
<p><strong>初次尝试</strong>：一个直接的想法是在手机浏览器中输入 <code>http://localhost:4000</code>。这个尝试必然会失败。其原因是 <code>localhost</code> 是一个特殊的环回地址，它指向设备自身。手机访问 <code>localhost</code>，访问的是手机自己，而非提供服务的电脑。</p>
</li>
<li>
<p><strong>二次尝试</strong>：在理解了 <code>localhost</code> 的局限性后，基于咱们已经学习过的计算机网络知识，下一步自然是尝试使用电脑的局域网 IP 地址。在 macOS 上我们可以通过 “设置 -&gt; 网络” 查到电脑的 IP，假设为 <code>192.168.1.100</code>，于是在手机上访问 <code>http://192.168.1.100:4000</code>。然而，这种尝试也会失败，浏览器会显示连接超时或无法访问。</p>
</li>
</ol>
<p>这就引出了问题的核心：在网络层面上，数据包已经能够从手机路由到目标主机，为什么连接依然无法建立？这表明问题很可能出在更高层，即运行在主机上的服务程序本身。</p>
<ol>
<li>
<p><strong>验证网络层 (Layer 3) 及以下是否通畅</strong><br>
在怀疑上层应用问题之前，我们必须百分之百确认基础网络是连通的。<code>ping</code> 命令是验证网络层连通性的最佳工具，它使用 ICMP 协议工作。我们可以在 iPhone 上安装任意一款网络调试工具（比如 <a href="https://apps.apple.com/cn/app/inettools-ping-dns-portscan/id561659975">iNetTools</a>）然后执行：</p>
<pre><code class="language-bash">ping 192.168.1.100
</code></pre>
<p>如果 <code>ping</code> 成功收到回复，我们将获得一条至关重要的信息：从手机到电脑的 <strong>网络层及以下的物理层、数据链路层是完全通畅的</strong>。数据包确实已经成功抵达了目标主机的网络协议栈。这就允许我们排除掉所有底层网络问题（如 Wi-Fi 隔离、IP 冲突、子网错误等），将注意力集中到更高层次。</p>
</li>
<li>
<p><strong>聚焦传输层 (Layer 4) 的可能性</strong><br>
既然网络路径没有问题，数据包在传输层“消失”的可能性就大大增加。在这一层，主要有两个实体在工作：<strong>操作系统内核（防火墙）</strong> 和 <strong>应用程序本身</strong>。</p>
<ul>
<li><strong>可能性 A：被防火墙拦截</strong>。电脑的防火墙可能设定了规则，允许 ICMP 包（<code>ping</code>）通过，但阻止了针对 <code>4000</code> 端口的 TCP 连接请求。这是一个非常合理的怀疑点。</li>
<li><strong>可能性 B：端口上没有服务在监听</strong>。应用程序在启动时，需要向操作系统内核申请监听一个或多个具体的“地址-端口”对。如果程序只申请监听 <code>127.0.0.1:4000</code>，那么当一个目标地址是 <code>192.168.1.100:4000</code> 的数据包到达时，内核会发现没有任何程序在等待这个数据包，于是只能将其丢弃。</li>
</ul>
</li>
<li>
<p><strong>使用工具做出最终裁定</strong><br>
现在，我们需要一个工具来区分到底是可能性 A 还是 B。<code>lsof</code> 命令的作用正在于此，它能直接查询操作系统内核，告诉我们“哪个进程正在监听哪个地址的哪个端口”，从而绕过所有猜测。</p>
<pre><code class="language-bash">lsof -i :4000
</code></pre>
<p>其输出结果：</p>
<pre><code>COMMAND     PID   USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
Gridea    13682 rakuyo   50u  IPv4 0x7e41bc65e0e51533      0t0  TCP localhost:terabase (LISTEN)
</code></pre>
<p>这个结果明确地告诉我们，<code>Gridea</code> 进程监听的地址是 <code>localhost</code>。这直接证实了<strong>可能性 B</strong>。数据包并非被防火墙拦截，而是在到达内核后，因找不到对应的监听程序而被丢弃。至此，问题根源被精准定位。</p>
</li>
</ol>
<p><strong>解决方案</strong></p>
<p>诊断出根源后，解决方案便是在服务层面进行修正。但是很可惜的是 Gridea 并没有提供修改的选项。否则我们可以将默认的 <code>localhost</code> 或 <code>127.0.0.1</code> 修改为 <code>0.0.0.0</code>，实现监听地址的修改。</p>
<blockquote>
<p><code>0.0.0.0</code> 是一个特殊的地址，它指示操作系统监听本机所有可用的网络接口，包括环回地址和所有局域网地址。</p>
</blockquote>
<p>这个排查过程清晰地展示了分层模型在解决实际问题时的指导作用。若不理解网络层的地址和监听机制，开发者可能会陷入反复检查防火墙、网络设置的无效循环中。而通过运用正确的理论知识和诊断工具，则可以快速、精准地定位问题根源。</p>
<h2 id="分层视角下的网络安全">分层视角下的网络安全</h2>
<p>分层模型也为我们理解和应对网络安全问题提供了一个清晰的框架。攻击可能发生在任何一层：</p>
<ul>
<li><strong>数据链路层安全</strong>：攻击者在局域网内，可以通过 <strong>ARP 欺骗</strong>来冒充网关，窃听或篡改流量；或者通过 <strong>MAC 泛洪攻击</strong>耗尽交换机的 MAC 地址表，使其变为“集线器”，从而嗅探整个网络的流量。</li>
<li><strong>网络层安全</strong>：攻击者可以伪造源 IP 地址（<strong>IP 欺骗</strong>）来隐藏身份或嫁祸他人。经典的 <strong>DDoS 攻击</strong>（如 SYN Flood）也利用了 IP 层的机制，发送大量伪造源 IP 的连接请求，耗尽服务器资源。</li>
<li><strong>传输层安全</strong>：<strong>端口扫描</strong>是黑客探测目标主机开放服务的主要手段，它直接作用于传输层的端口。</li>
<li><strong>应用层安全</strong>：这是最广为人知的攻击面，包括 <strong>SQL 注入</strong>、<strong>跨站脚本（XSS）</strong>、<strong>CSRF</strong> 等，它们都利用了应用程序自身的逻辑漏洞。</li>
</ul>
<p>为了应对这些威胁，安全协议也作用于不同层面。例如，<strong>IPsec</strong> 工作在网络层，提供端到端的加密和认证。而我们熟知的 <strong>TLS/SSL</strong> 则比较特殊，它逻辑上位于应用层和传输层之间，为上层的应用数据提供加密、完整性保护和身份认证。此外，另一种强大的安全工具是 VPN（虚拟专用网络）。技术如 <strong>WireGuard</strong> 通过创建一张虚拟网卡，并在网络层对所有数据进行加密封装，形成一个安全的“隧道”。所有进出你设备的流量都通过这个隧道传输，从而有效地保护了通信的私密性和完整性，抵御了中间人攻击。更深入的探讨可以参见 <a href="/computer-network-virtual-nic-and-wireguard/">《计算机网络之四 - 虚拟网卡与 WireGuard》</a>。</p>
<h2 id="模型的局限性与争议">模型的局限性与争议</h2>
<p>分层模型是完美的吗？并非如此。在学术和工程实践中，它们也存在一些争议：</p>
<ul>
<li><strong>归属争议</strong>：有些重要协议难以被完美地归入某一层。例如，<strong>ARP</strong> 协议通过 IP 地址查询 MAC 地址，它似乎横跨了网络层和数据链路层。<strong>ICMP</strong> 协议（<code>ping</code> 命令所使用的协议）被 IP 协议承载，但它本身是为网络层提供控制和错误信息的，其位置也存在争议。</li>
<li><strong>效率问题</strong>：严格的分层会带来性能开销。在一些高性能计算场景中，为了追求极致的低延迟，可能会出现“跨层”操作，绕过某些协议栈以加速数据处理。</li>
<li><strong>模型与现实的脱节</strong>：OSI 模型的会话层和表示层在现实中很少被独立实现，它们的功能往往被应用层自身所包含，这也是 TCP/IP 模型将其合并的原因。</li>
</ul>
<p>理解这些局限性，能帮助我们更辩证地看待这些模型，认识到它们是用于理解复杂系统的强大工具，而非一成不变的教条。</p>
<h2 id="总结">总结</h2>
<p>通过本文的深度剖析，我们不仅了解了 OSI 和 TCP/IP 模型是什么，更探讨了它们的设计哲学、历史演进、协议细节、实践流程乃至理论局限。</p>
<p>网络分层模型，本质上是一种“分而治之”的工程智慧。它将一个不可能完成的复杂任务，拆解为一系列定义清晰、可以管理的子任务。理解这些分层模型，就像是拿到了一张高精度的网络世界地图。当我们再去审视之前文章中讨论的 HTTP、TCP、IP、DHCP 等协议时，便能清晰地知道它们在整个通信流程中所处的位置和扮演的角色。有了这个“世界观”，我们后续探索更复杂的网络技术时，才能做到胸有成竹，游刃有余。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://blog.rakuyo.dev/vibe-coding-sweet-struggle/" class="post-title gt-a-link">
                    Vibe Coding 的两面：一周体验的甜蜜与挣扎
                </a>
            </div>
        

        

        
            
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
<script>
    // md5.min.js
    !function(n){
        "use strict";
        function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}
        function f(n,t,r,e,o,u){return d((c=d(d(t,n),d(e,u)))<<(f=o)|c>>>32-f,r);var c,f}
        function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}
        function v(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}
        function g(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}
        function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}
        function i(n,t){var r,e,o,u,c;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;var f=1732584193,i=-271733879,a=-1732584194,h=271733878;for(r=0;r<n.length;r+=16)f=l(e=f,o=i,u=a,c=h,n[r],7,-680876936),h=l(h,f,i,a,n[r+1],12,-389564586),a=l(a,h,f,i,n[r+2],17,606105819),i=l(i,a,h,f,n[r+3],22,-1044525330),f=l(f,i,a,h,n[r+4],7,-176418897),h=l(h,f,i,a,n[r+5],12,1200080426),a=l(a,h,f,i,n[r+6],17,-1473231341),i=l(i,a,h,f,n[r+7],22,-45705983),f=l(f,i,a,h,n[r+8],7,1770035416),h=l(h,f,i,a,n[r+9],12,-1958414417),a=l(a,h,f,i,n[r+10],17,-42063),i=l(i,a,h,f,n[r+11],22,-1990404162),f=l(f,i,a,h,n[r+12],7,1804603682),h=l(h,f,i,a,n[r+13],12,-40341101),a=l(a,h,f,i,n[r+14],17,-1502002290),f=v(f,i=l(i,a,h,f,n[r+15],22,1236535329),a,h,n[r+1],5,-165796510),h=v(h,f,i,a,n[r+6],9,-1069501632),a=v(a,h,f,i,n[r+11],14,643717713),i=v(i,a,h,f,n[r],20,-373897302),f=v(f,i,a,h,n[r+5],5,-701558691),h=v(h,f,i,a,n[r+10],9,38016083),a=v(a,h,f,i,n[r+15],14,-660478335),i=v(i,a,h,f,n[r+4],20,-405537848),f=v(f,i,a,h,n[r+9],5,568446438),h=v(h,f,i,a,n[r+14],9,-1019803690),a=v(a,h,f,i,n[r+3],14,-187363961),i=v(i,a,h,f,n[r+8],20,1163531501),f=v(f,i,a,h,n[r+13],5,-1444681467),h=v(h,f,i,a,n[r+2],9,-51403784),a=v(a,h,f,i,n[r+7],14,1735328473),f=g(f,i=v(i,a,h,f,n[r+12],20,-1926607734),a,h,n[r+5],4,-378558),h=g(h,f,i,a,n[r+8],11,-2022574463),a=g(a,h,f,i,n[r+11],16,1839030562),i=g(i,a,h,f,n[r+14],23,-35309556),f=g(f,i,a,h,n[r+1],4,-1530992060),h=g(h,f,i,a,n[r+4],11,1272893353),a=g(a,h,f,i,n[r+7],16,-155497632),i=g(i,a,h,f,n[r+10],23,-1094730640),f=g(f,i,a,h,n[r+13],4,681279174),h=g(h,f,i,a,n[r],11,-358537222),a=g(a,h,f,i,n[r+3],16,-722521979),i=g(i,a,h,f,n[r+6],23,76029189),f=g(f,i,a,h,n[r+9],4,-640364487),h=g(h,f,i,a,n[r+12],11,-421815835),a=g(a,h,f,i,n[r+15],16,530742520),f=m(f,i=g(i,a,h,f,n[r+2],23,-995338651),a,h,n[r],6,-198630844),h=m(h,f,i,a,n[r+7],10,1126891415),a=m(a,h,f,i,n[r+14],15,-1416354905),i=m(i,a,h,f,n[r+5],21,-57434055),f=m(f,i,a,h,n[r+12],6,1700485571),h=m(h,f,i,a,n[r+3],10,-1894986606),a=m(a,h,f,i,n[r+10],15,-1051523),i=m(i,a,h,f,n[r+1],21,-2054922799),f=m(f,i,a,h,n[r+8],6,1873313359),h=m(h,f,i,a,n[r+15],10,-30611744),a=m(a,h,f,i,n[r+6],15,-1560198380),i=m(i,a,h,f,n[r+13],21,1309151649),f=m(f,i,a,h,n[r+4],6,-145523070),h=m(h,f,i,a,n[r+11],10,-1120210379),a=m(a,h,f,i,n[r+2],15,718787259),i=m(i,a,h,f,n[r+9],21,-343485551),f=d(f,e),i=d(i,o),a=d(a,u),h=d(h,c);return[f,i,a,h]}
        function a(n){var t,r="",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}
        function h(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}
        function e(n){var t,r,e="0123456789abcdef",o="";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),o+=e.charAt(t>>>4&15)+e.charAt(15&t);return o}
        function r(n){return unescape(encodeURIComponent(n))}
        function o(n){return a(i(h(t=r(n)),8*t.length));var t}
        function u(n,t){return function(n,t){var r,e,o=h(n),u=[],c=[];for(u[15]=c[15]=void 0,16<o.length&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(h(t)),512+8*t.length),a(i(c.concat(e),640))}(r(n),r(t))}
        function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}
        "function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t;
    }(this);
</script>


<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '30875151c07a20ceb163',
    clientSecret: '9a57fd47038f45827326ab5b0ab8c796f184a46f',
    repo: 'rakuyomo.github.io',
    owner: 'rakuyoMo',
    admin: ['rakuyoMo'],
    id: md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false       // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first"></div>
    <div class="social-container">
        
            
                <a href="https://github.com/rakuyoMo" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        无常为常，变化即永恒
    </div>
    <div>
        Theme <a href="https://github.com/rakuyoMo/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://blog.rakuyo.dev/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
